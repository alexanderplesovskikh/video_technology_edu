# Управление оборудованием

Протокол NDI позволяет управлять PTZ камерами, поддерживающими этот протокол (поворот, наклон, увеличение, экспозиция, цвет). Это можно делать как программно через NDI Tools, так и аппаратно с помощью поддерживающих протокол NDI пультов.

ONVIF (Open Network Video Interface Forum) – это международный стандарт, разработанный для обеспечения совместимости между различными устройствами видеонаблюдения, такими как IP-камеры, видеорегистраторы (NVR/DVR), системы контроля доступа и другие устройства безопасности. Основная цель ONVIF заключается в упрощении интеграции различных устройств от разных производителей в единую систему видеонаблюдения, а также в обеспечении возможности их взаимодействия через открытые протоколы.

### Структура стандарта ONVIF

Стандарт ONVIF включает несколько профилей, каждый из которых предназначен для выполнения определенных задач:

#### Профили ONVIF

Вот обновленная таблица с назначением профилей ONVIF в формате списка:

| Профиль   | Назначение                                                                                                                                              |
|-----------|---------------------------------------------------------------------------------------------------------------------------------------------------------|
| Profile S | \- Запись, поиск и воспроизведение видео.<br />- Управление архивами.<br />- Работа с NVR/DVR системами и камерами с поддержкой записи.                  |
| Profile T | \- Расширенная потоковая передача видео.<br />- Улучшенные алгоритмы сжатия (H.265).<br />- Метаданные: детекторы движения, аналитика.                   |
| Profile C | \- Интеграция систем контроля доступа (ACS / СКУД).<br />- Управление дверными замками, считывателями карт и другими элементами физической безопасности. |
| Profile G | \- Управление записью и настройкой камер.<br />- Конфигурация параметров камеры: разрешение, частота кадров, битрейт.                                    |
| Profile Q | \- Быстрое подключение к устройствам.<br />- Минимизация задержек при настройке и управлении устройствами.                                               |
| Profile A | \- Интеграция систем аналитики.<br />- Расширенная обработка данных с видеокамер.                                                                        |
| Profile M | \- Работа с мультимедийным контентом.<br />- Управление аудио- и видеопотоками.                                                                          |

### Техническая реализация стандарта ONVIF

ONVIF использует веб-сервисы для реализации своих функций. Основные компоненты технической реализации включают HTTP, SOAP и XML.

#### HTTP

Протокол HTTP (HyperText Transfer Protocol) является основным транспортным уровнем для обмена данными между устройствами ONVIF. Все запросы и ответы передаются через HTTP, что делает взаимодействие простым и доступным для большинства современных платформ и языков программирования.

#### SOAP

SOAP (Simple Object Access Protocol) – это протокол для обмена структурированными сообщениями в распределённых вычислительных системах. В контексте ONVIF, SOAP используется для передачи запросов и ответов между клиентами и серверами. Сообщения SOAP представляют собой XML-документы, содержащие данные о запросах и ответах.

#### XML

XML (eXtensible Markup Language) – это язык разметки, который используется для описания структуры сообщений SOAP. Каждый запрос и ответ содержат заголовки и тело сообщения, где тело представляет собой XML-документ, содержащий необходимые параметры и данные.

### Onvif в Python

Для работы с ONVIF в Python существует несколько библиотек, которые позволяют легко взаимодействовать с устройствами, поддерживающими этот стандарт. Одной из наиболее популярных библиотек является onvif_zeep.

Пример установки библиотеки:

```bash
pip install onvif_zeep
```

### Примеры использования

#### Простое подключение к камере

```python
from onvif import ONVIFCamera

# Подключение к камере
mycam = ONVIFCamera('192.168.0.100', 80, 'admin', 'password')
media_service = mycam.create_media_service()

# Получение списка профилей
profiles = media_service.GetProfiles()
for profile in profiles:
    print(profile.Name)
```

В этом примере мы подключаемся к камере с использованием IP-адреса, порта, имени пользователя и пароля. Затем получаем список профилей, доступных на этой камере.

#### Управление PTZ (Pan-Tilt-Zoom)

PTZ-функции позволяют управлять положением камеры (панорамирование, наклон и масштабирование).

```python
from onvif import ONVIFCamera

# Подключение к камере
mycam = ONVIFCamera('192.168.0.100', 80, 'admin', 'password')
ptz_service = mycam.create_ptz_service()

# Получаем текущие настройки PTZ
request = ptz_service.create_type('GetStatus')
status = ptz_service.GetStatus(StatusToken=request)
print(status.Position)

# Перемещение камеры вверх
request = ptz_service.create_type('ContinuousMove')
request.Velocity.PanTilt.x = 0.1  # Скорость панорамирования
request.Velocity.PanTilt.y = -0.1  # Скорость наклона
ptz_service.ContinuousMove(request)
```

Этот пример демонстрирует, как получить текущее положение камеры и переместить её вверх.

#### Пример команды SOAP для получения статуса PTZ

Вот пример SOAP-запроса для получения текущего состояния PTZ:

```xml
<s:Envelope xmlns:s="http://www.w3.org/2003/05/soap-envelope">
  <s:Body>
    <GetStatus xmlns="http://www.onvif.org/ver20/ptz/wsdl">
      <ProfileToken>token</ProfileToken>
    </GetStatus>
  </s:Body>
</s:Envelope>
```

Ответ будет содержать информацию о текущем положении камеры и других параметрах PTZ.

#### Пример программы управления камерой PTZ с клавиатуры

Для создания программы на Python 3, которая позволит управлять камерой PTZ с помощью клавиш со стрелками и зумом, нужно использовать библиотеку onvif_zeep вместе с модулем keyboard. Ниже приведен пример кода, который реализует такую функциональность:

```python
import time
from onvif import ONVIFCamera
import keyboard

# Настройки подключения к камере
IP_ADDRESS = '192.168.0.100'
PORT = 80
USERNAME = 'admin'
PASSWORD = 'password'

# Функция для перемещения камеры
def move(ptz, request, timeout):
    ptz.ContinuousMove(request)
    time.sleep(timeout)
    ptz.Stop({'ProfileToken': request.ProfileToken})

# Функция для изменения масштаба (зум)
def zoom(ptz, request, value, timeout):
    request.Velocity.Zoom.value = value
    ptz.ContinuousMove(request)
    time.sleep(timeout)
    ptz.Stop({'ProfileToken': request.ProfileToken})

# Соединяемся с камерой
camera = ONVIFCamera(IP_ADDRESS, PORT, USERNAME, PASSWORD)
ptz = camera.create_ptz_service()

# Получаем текущий профиль
media = camera.create_media_service()
profiles = media.GetProfiles()
token = profiles[0].token

# Запрашиваем статус PTZ
request = ptz.create_type('GetStatus')
status = ptz.GetStatus(StatusToken=token)
position = status.Position

# Создаем начальный запрос для непрерывного движения
continuous_move = ptz.create_type('ContinuousMove')
continuous_move.ProfileToken = token

while True:
    if keyboard.is_pressed("left"):
        continuous_move.Velocity.PanTilt.x = -0.5  # Левый поворот
        move(ptz, continuous_move, 0.25)
    elif keyboard.is_pressed("right"):
        continuous_move.Velocity.PanTilt.x = 0.5  # Правый поворот
        move(ptz, continuous_move, 0.25)
    elif keyboard.is_pressed("up"):
        continuous_move.Velocity.PanTilt.y = -0.5  # Движение вверх
        move(ptz, continuous_move, 0.25)
    elif keyboard.is_pressed("down"):
        continuous_move.Velocity.PanTilt.y = 0.5  # Движение вниз
        move(ptz, continuous_move, 0.25)
    elif keyboard.is_pressed("+") or keyboard.is_pressed("="):
        zoom(ptz, continuous_move, 0.5, 0.25)  # Увеличение (Zoom In)
    elif keyboard.is_pressed("-"):
        zoom(ptz, continuous_move, -0.5, 0.25)  # Уменьшение (Zoom Out)
    
    # Остановка программы по нажатию клавиши ESC
    if keyboard.is_pressed("esc"):
        break

# Завершаем соединение с камерой
camera.close()
```

### Пояснение к коду:

1. Подключение к камере: Мы создаем объект ONVIFCamera с указанием IP-адреса, порта, логина и пароля. Далее создается объект сервиса PTZ (create_ptz_service) для управления движением камеры.
2. Получение профиля: Для корректной работы с камерой необходимо получить токен профиля. Это делается с помощью метода GetProfiles.
3. Создание запросов: Мы создаем запросы для движения камеры (ContinuousMove), остановки (Stop) и изменения масштаба (zoom).
4. Обработка событий клавиатуры: Модуль keyboard отслеживает нажатия клавиш и вызывает соответствующие функции для перемещения камеры или изменения масштаба.
5. Остановка программы: Программа завершает свою работу при нажатии клавиши ESC.

### Установка зависимостей:

Перед запуском программы убедитесь, что установлены все необходимые зависимости:

```bash
pip install onvif_zeep keyboard
```

VISCA — это профессиональный протокол управления PTZ-видеокамерами. Он был разработан Sony для использования в камерах видеонаблюдения.

Аппаратный интерфейс: RS-232. Управление через RS-232 — наследие аналогового прошлого, когда камеры управлялись отдельно от видеосигнала, который передавался по коаксиальному кабелю.

# VISCA структура сообщения

Базовая единица связи VISCA называется пакетом.

Первый байт пакета называется заголовком и содержит адреса отправителя и получателя.

Например, заголовок пакета, отправленного на устройство (с адресом 1) от контроллера (адрес 0) представляет собой:

| 1 | 0 | 0 | 0 | 0 | 0 | 0 | 1 |
|---|---|---|---|---|---|---|---|

где 1000.00012 в двоичной — это 8116 в шестнадцатеричной СС. Пакет, отправленный на устройство (адрес 2) — 1000.00102 = 8216.

![Рисунок 1.](.attachments.55936/image.png)

Заголовок ответного пакета от устройства, которому присвоен адрес 1, равен 1001.00002 = 9016.

Пакет от устройства, которому присвоен адрес 2, равен A016.

Некоторые командные настройки могут быть отправлены на все устройства одновременно (широковещательная передача).

Функция широковещательной передачи недоступна для передачи VISCA по IP. В случае широковещательной передачи заголовок должен быть 88 в шестнадцатеричном формате. Когда терминатор равен FF16, это означает конец пакета.

# Временная диаграмма

Поскольку обработка команды VISCA может выполняться максимум один раз в вертикальном (V) цикле, для возврата подтверждения/завершения запроса требуется максимум 4V-цикла. Вертикальный цикл подразумевает один полукадр. Если необходимо отправить несколько команд последовательно, нужно сначала дождаться подтверждения или сообщения об ошибке от предыдущей команды, прежде чем отправлять следующую.

RxD (Receive Data — приём данных)

TxD (Transmit Data — передача данных)

![Рисунок 2.](.attachments.55936/image%20%282%29.png)

# Команды и запрос

Команда — отправляет команды на устройство

Запрос — используется для запроса о текущем состоянии устройства

```
8X QQ RR … FF # Структура пакета
```

X — адрес устройства (X = 1 для VISCA по IP)

QQ — 01 (Команда), 09 (Запрос)

RR — код категории

# Виды сообщений

ACK сообщение

- возвращается устройством, когда оно получает команду
- в случае запроса не возвращается

  ![Рисунок 3.](.attachments.55936/image%20%283%29.png)

Сообщение о завершении

- возвращается устройством по завершении выполнения команд или запросов
- данные ответа на запрос содержатся после 3-го байта пакета
- если ACK сообщение отсутствует, номер сокета будет содержать 0

Сообщение об ошибке

- когда команда или запрос не могут быть выполнены или завершены с ошибкой, то

вместо сообщения о завершении возвращается сообщение об ошибке:

![Рисунок 4.](.attachments.55936/image%20%284%29.png)

ACK/Completion Messages

| Команды    | Код команды              | Комментарии                                 |
|------------|--------------------------|---------------------------------------------|
| ACK        | z0 4y FF (y: Socket No.) | Возвращается, когда команда принята.        |
| Завершение | z0 5y FF (y: Socket No.) | Возвращается, когда команда была выполнена. |

Error Messages

| Команды                  | Код команды                 | Комментарии                                                                                                                                                                           |
|--------------------------|-----------------------------|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| Синтаксическая ошибка    | z0 60 02 FF                 | Возвращается, когда формат команды отличается или когда команда содержит недопустимые параметры                                                                                       |
| Командный буфер заполнен | z0 60 03 FF                 | Не удалось принять команду, которая получена во время выполнения двух командв данный момент.                                                                                          |
| Команда отменена         | z0 6y 04 FF (y: Socket No.) | Возвращается, когда команда отменяется.                                                                                                                                               |
| Нет сокета               | z0 6y 05 FF (y: Socket No.) | Возвращается, когда ни одна команда не выполняется в сокете или когда указан недопустимый номер сокета.                                                                               |
| Команда не выполняется   | z0 6y 41 FF (y: Socket No.) | Возвращается, когда команда не может быть выполнена из-за текущих условий. Например, когдав режиме автоматической фокусировки принимается команда для управления ручной фокусировкой. |

# Номер сокета

Когда команды отправляются на устройство, обратно отправляется сообщение о завершении или сообщения об ошибке, далее можно слать следующую команду. Устройство имеет два набора буферов для команд, так что может быть получено до двух команд.  Когда устройство получает команды, оно уведомляет, какой буфер был использован, используя номер сокета в ACK-сообщении. Таким образом, ACK-сообщение и сообщение об ошибке указывают, какая команда завершилась. Даже когда используются два буфера, команда управления устройством и некоторые запросы могут быть выполнены. В таком случае сообщение ACK отсутствует и возвращается только сообщение о завершении сокета с номером 0. Таким образом, номер сокета — это просто номер команды.

# VISCA over IP

С функцией VISCA over IP можно управлять камерой с помощью VISCA на контроллере, оснащенном возможностями IP-связи по локальной сети. Вы можете одновременно подключать к сети до 5 контроллеров.

Характеристики VISCA по IP:

• Интерфейс: RJ-45 10Base-T/100Base-TX

• Интернет-протокол: IPv4

• Транспортный протокол: UDP

• IP-адрес: Устанавливается командой настройки IP-карты (стр. 34)

• Адрес порта: 52381

![Рисунок 5.](.attachments.55936/image%20%285%29.png)

![Рисунок 6.](.attachments.55936/image%20%286%29.png)

Контроллеры и периферийные устройства подключены к однонаправленному кольцу. При IP-соединении контроллеры и периферийные устройства подключаются по шине через локальную сеть.

Заголовок сообщения (8 байт) и полезной нагрузки (от 1 до 16 байт):

![Рисунок 7.](.attachments.55936/image%20%287%29.png)

Payload type:

Содержится в первых двух байтах сообщения (байт 0 и байт 1). Полезная нагрузка содержит различную информацию о командах и запросах.

# Команды VISCA

Команды протокола VISCA используются для управления камерой, получения информации о её настройках и получения информации о статусе отправки команды.

Команды VISCA разделены на:

- Команды возврата
- Команды управления
- Команды запроса
- Значения поворота/наклона камеры, масштабирования и экспозиции

С подробным списком команд можно ознакомиться по данной ссылке:

# Пример реализации

С помощью данной библиотеки, реализующей функционал протокола VISCA over IP, можно задать камере поворачиваться влево и вправо, как если бы она качала головой:

```
import time
from visca_over_ip import Camera

cam = Camera('192.168.0.123')  # IP-адрес камеры 

while True:
    cam.pantilt(pan_speed=-12, tilt_speed=0)
    time.sleep(1)  # wait one second
    cam.pantilt(pan_speed=12, tilt_speed=0)
```

Существует две версии протокола Pelco:

- Pelco P
- Pelco D

::: info
Pelco D -- более новая версия, рассматривать устаревшую Pelco P мы не будем.

:::

Pelco D — протокол управления для моторизованных камер видеонаблюдения, названный по имени компании-разработчика протокола. Используется как через аппаратный интерфейс (обычно RS485, но может работать и через RS232, RS422), так и по сети в IP-версии.

# Оборудование

![Рисунок 1. Интерфейсная панель IP-PTZ камеры.](.attachments.55937/image.png)

![Рисунок 2. Компактный джойстик с интерфейсом Pelco.](.attachments.55937/image%20%282%29.png)

К шине подключен только один ведущий узел, и один или несколько (максимальное число 255) подчиненных узлов также подключены к одной и той же последовательной шине. Связь всегда инициируется мастером. Подчиненные узлы никогда не будут передавать данные без получения запроса от главного узла., также подчиненные узлы никогда не будут взаимодействовать друг с другом. Главный узел одновременно инициирует только одну транзакцию Pelco (т.е. отсутствует возможность широковещательной передачи). В этом режиме транзакция Pelco состоит из 2 сообщений: запроса от ведущего устройства и ответа от ведомого устройства.

Исторически команды Pelco отправлялись по отдельной линии управления (обычно это RS-485). Однако, по мере развития сетей и их применения в видеотехнологиях вариант с прокладыванием проводов стал избыточным и появились IP-версии некогда “проводных” протоколов (Pelco-over-IP).

# Команды

Команда представляет собой код из 7 байт

| Function                     | Byte1 | Byte2   | Byte3 | Byte4 | Byte5           | Byte6          | Byte7 |
|------------------------------|-------|---------|-------|-------|-----------------|----------------|-------|
| Up                           | 0xFF  | Address | 0x00  | 0x08  | Pan Speed       | Tilt Speed     | SUM   |
| Down                         | 0xFF  | Address | 0x00  | 0x10  | Pan Speed       | Tilt Speed     | SUM   |
| Left                         | 0xFF  | Address | 0x00  | 0x04  | Pan Speed       | Tilt Speed     | SUM   |
| Right                        | 0xFF  | Address | 0x00  | 0x02  | Pan Speed       | Tilt Speed     | SUM   |
| Upleft                       | 0xFF  | Address | 0x00  | 0x0C  | Pan Speed       | Tilt Speed     | SUM   |
| Upright                      | 0xFF  | Address | 0x00  | 0x0A  | Pan Speed       | Tilt Speed     | SUM   |
| DownLeft                     | 0xFF  | Address | 0x00  | 0x14  | Pan Speed       | Tilt Speed     | SUM   |
| DownRight                    | 0xFF  | Address | 0x00  | 0x12  | Pan Speed       | Tilt Speed     | SUM   |
| Zoom In                      | 0xFF  | Address | 0x00  | 0x20  | 0x00            | 0x00           | SUM   |
| Zoom Out                     | 0xFF  | Address | 0x00  | 0x40  | 0x00            | 0x00           | SUM   |
| Focus Far                    | 0xFF  | Address | 0x00  | 0x80  | 0x00            | 0x00           | SUM   |
| Focus Near                   | 0xFF  | Address | 0x01  | 0x00  | 0x00            | 0x00           | SUM   |
| Set Preset                   | 0xFF  | Address | 0x00  | 0x03  | 0x00            | Preset ID      | SUM   |
| Clear Preset                 | 0xFF  | Address | 0x00  | 0x05  | 0x00            | Preset ID      | SUM   |
| Call Preset                  | 0xFF  | Address | 0x00  | 0x07  | 0x00            | Preset ID      | SUM   |
| Query Pan Position           | 0xFF  | Address | 0x00  | 0x51  | 0x00            | 0x00           | SUM   |
| Query Pan Position Response  | 0xFF  | Address | 0x00  | 0x59  | Value High Byte | Value Low Byte | SUM   |
| Query Tilt Position          | 0xFF  | Address | 0x00  | 0x53  | 0x00            | 0x00           | SUM   |
| Query Tilt Position Response | 0xFF  | Address | 0x00  | 0x5B  | Value High Byte | Value Low Byte | SUM   |
| Query Zoom Position          | 0xFF  | Address | 0x00  | 0x55  | 0x00            | 0x00           | SUM   |
| Query Zoom Position Response | 0xFF  | Address | 0x00  | 0x5D  | Value High Byte | Value Low Byte | SUM   |

# Протокол ArtNet

Art-Net является простой реализацией DMX512 протокола по UDP, в котором информация управления каналами передается в IP пакетах, как правило, по локальной сети(LAN), по технологии Ethernet. ArtNet является протоколом с обратной связью. Как правило в приборах работающих по ArtNet имеется функция ответа на принятые данные. Например прибор получил данные, и может отправить ответ, что он их получил.

ArtNet может передавать абсолютно всё, вплоть до файлов. Артнет может осуществлять передачу координат приборов, а также может передавать таймкод (адресно-временной код — цифровые данные о времени, записываемые и передаваемые совместно с изображением или звуком. Применяется для синхронизации различных медиа систем — звук, видео, свет и т.д.).

ArtNet устройства используют для коммутации между собой так называемые узлы. В качестве узлов могут выступать преобразователи Artnet в физический DMX512, либо световые приборы или оборудование, уже имеющее встроенный интерфейс Art-Net. В тоже время сервер может раздавать пакеты как всем узлам ArtNet, так и отдельно выбранным. В качестве Artnet сервера может служить компьютер со световым программным обеспечением или световая консоль.

Каждое пространство из 512 DMX каналов в протоколе Art-Net называется Universe. Каждый узел (устройство) может поддерживать максимум 1024 каналов DMX (2 Universe) на одном ip-адресе. Каждые 16 Universe объединяются в подсеть. Группа из 16 подсетей (256 Universe) образует сеть. Максимальное количество сетей — 128. Итого в протоколе Artnet количество узлов может достигать 32768 шт, каждый с 512 DMX каналами.

Адреса Артнет обычно используются в пределах 2.0.0.0/8, но и в обычных локальных сетях 192.168.1.0/255 работают без проблем.

Наглядная схема подключения устройств с использованием узлов представлена на рисунке 2:

![Рисунок 1 – Множественное подключение устройств по ArtNet.](.attachments.55942/image.png)

# Примеры реализации

## Задача 1

В стенде расположена светодиодная лента, управляемая с помощью протокола DMX. В свою очередь она соединена с USB-DMX контроллером, который подключен к одноплатному компьютеру (Jetson Nano).

Работать с USB-DMX контроллером можно двумя путями:

1. через библиотеку на Python, запуская скрипты на одноплатном компьютере
2. через API и веб-интерфейс

В этой лабораторной работе Вам предстоит пойти по второму (простому) пути.

Задача состоит в следующем:

- получить цвет, который установлен на светодиодной ленте
- рассчитать цвет, который дополнит исходный до белого (в RGB)
- установить этот цвет на светодиодную ленту

Документация API: http://172.18.212.21:8085/docs

При выполнении задания в GitLab нужно использовать токен из переменной окружения \`ACCESS_TOKEN\`.

Итак, вначале нужно импортировать библиотеки необходимые для выполнения HTTP-запросов, обработки данных JSON и доступа к переменным окружения.

```
import requests
import json
import os
```

Далее создаем переменные, содержащие ссылку на страницу с методом по получению информации о цвете и отправке информации.

```
get_request_url = 'http://172.18.212.21:8085/api/v1/color' 
put_request_url = 'http://172.18.212.21:8085/api/v1/color'
```

Далее присваиваем переменной  token значение токена из среды Gitlab. Это значение появляется в момент выполнения кода в Gitlab. Этот токен нужен для заголовка запроса, чтобы идентифицировать клиента. Затем нужно получить ответ по данному запросу и конвертировать в формат json.

```
token = os.getenv('ACCESS_TOKEN')
headers = {"Authorization": "Bearer " + token, 'Content-Type': 'application/json'}
response = requests.get(get_request_url, headers=headers)
response_data = json.loads(response.text)
initial_color = response_data['color']
```

Далее значение цвета, полученного в шестнадцатеричного формате преобразуется в RGB с помощью функции hex_to_rgb(). Внутри функции создается пустой список для хранения значений RGB. Для каждой итерации код извлекает две шестнадцатеричные цифры из шестнадцатеричной строки и преобразует их в целое число с помощью int(hex\[i:i + 2\], 16). Полученное целое число добавляется к списку rgb. Наконец, функция возвращает кортеж, содержащий значения RGB. Таким образом, мы решили первую задачу.

```
def hex_to_rgb(hex):
    rgb = []
    for i in (0, 2, 4):
        x = int(hex[i:i + 2], 16)
        rgb.append(x)

    return tuple(rgb)
```

Далее для того, чтобы понять, какой цвет дополнит текущее значение до белого, нужно вспомнить, что белый цвет в RGB – это 255,255,255. Поэтому нужно просто вычесть из 255 значения каждого цвета. И чтобы впоследствие установить этот цвет на ленту создадим словарь с одной парой ключ-значение.

```
rgb = hex_to_rgb(initial_color[1:])
new_color = [255 - color for color in rgb]

put_request_data = {'color': new_color}
```

Чтобы отправить значение цвета на светодиодную ленту, воспользуемся функцией, отправляющей данные по ранее обозначенному адресу.

```
response = requests.put(put_request_url, data=json.dumps(put_request_data), headers=headers)
```

Весь код представлен ниже:

```
import requests
import json
import os

get_request_url = 'http://172.18.212.21:8085/api/v1/color' 
put_request_url = 'http://172.18.212.21:8085/api/v1/color'
token = os.getenv('ACCESS_TOKEN')
headers = {"Authorization": "Bearer " + token, 'Content-Type': 'application/json'}
response = requests.get(get_request_url, headers=headers)
response_data = json.loads(response.text)
initial_color = response_data['color']

def hex_to_rgb(hex):
    rgb = []
    for i in (0, 2, 4):
        x = int(hex[i:i + 2], 16)
        rgb.append(x)
    return tuple(rgb)

rgb = hex_to_rgb(initial_color[1:])
new_color = [255 - color for color in rgb]

put_request_data = {'color': new_color}

response = requests.put(put_request_url, data=json.dumps(put_request_data), headers=headers)
```

## Задача 2

Данное задание нацелено на управление светодиодной лентой, поддерживающей протокол DMX, через DMX-контроллер. Взаимодействовать с ним можно посредством библиотеки на Python.

::: info
Доступ к одноплатнику Jetson Nano осуществляется по ssh, который подключен к USB-DMX-контроллеру. IP-адрес для подключения по ssh: 172.18.212.22

:::

На вход программы подаётся цвет в формате RGB. Необходимо подсветить ленту этим цветом, запустив скрипт (написанный при помощи модуля udmx-pyusb) на jetson. Цвет подается программе как аргумент командной строки. Например: python solution.py 255 0 0

Для начала импортируем необходимые библиотеки. Модуль argparse позволяет разбирать аргументы, передаваемые скрипту при его запуске из командной строки, и даёт возможность пользоваться этими аргументами в скрипте. То есть речь идёт о том, что этот модуль позволяет предоставлять скрипту некие данные в момент его запуска, а этими данными скрипт сможет воспользоваться во время выполнения его кода.

```
from pyudmx
import pyudmx
import sys
import argparse
```

С использованием конструкции argparse.ArgumentParser(), создаётся объект parser. Далее, с помощью метода parser.add_argument(), описываются переменные red, green, blue. На следующем шаге в переменную args попадает результат разбора аргументов командной строки. То, что передано скрипту при запуске, теперь будет доступно в виде свойств red, green, blue объекта params. Также создается список color, содержащий RGB-значения, полученные из аргументов командной строки.

```
parser.add_argument('red')
parser.add_argument('green')
parser.add_argument('blue')
params = parser.parse_args(sys.argv[1:])
color = [int(params.red), int(params.green), int(params.blue)]
```

Подключаемся к контроллеру с помощью метода uDMXDevice. Создаем массив и заполняем его нулями. Далее присваиваем первым трем переменным значения каналов цвета. Затем с помощью метода send_single_value отправляем блок из 512 значений на контроллер. И закрываем соединение.

```
dev = pyudmx.uDMXDevice()`
dev.open()
cv = [0 for _ in range(0, 512)]
cv[0] = color[0]
cv[1] = color[1]
cv[2] = color[2]
sent = dev.send_multi_value(1, cv)
dev.close()
```

Весь код представлен ниже:

```
from pyudmx 
import pyudmx
import sys
import argparse
parser = argparse.ArgumentParser()
parser.add_argument('red')
parser.add_argument('green')
parser.add_argument('blue')
params = parser.parse_args(sys.argv[1:])
color = [int(params.red), int(params.green), int(params.blue)]
dev = pyudmx.uDMXDevice()
dev.open()
cv = [0 for _ in range(0, 512)]
cv[0] = color[0]
cv[1] = color[1]
cv[2] = color[2]
sent = dev.send_multi_value(1, cv)
dev.close()
```

Терминология DMX
- Chase – это последовательность изменений яркости и цвета световых приборов, проигрываемая в определенной последовательности. То есть, набор сцен, переключающихся между собой.
- DMX-контроллер – устройство, которое позволяет управлять освещением, используя протокол DMX.
- Ethernet протокол – стандарт организации локальных сетей, описанный в спецификациях IEEE и других организаций.
- RDM – Remote Device Management (или RDM) - это протокол управления, который работает параллельно с протоколом DMX и помогает основному протоколу, сглаживая некоторые минусы, которые есть в работе DMX.
- Traffic Art-Net (Art-Net трафик) - это передаваемая по сети информация в формате ArtNet.
- UDP (User Datagram Protocol) – прозрачный протокол в группе протоколов Internet, UDP обеспечивает обмен дейтаграммами без подтверждения или гарантий доставки.
- Universe – каждое пространство из 512 каналов в протоколе DMX. Это максимальный объем данных DMX, который может быть использован по одному кабелю DMX.
- XLR– тип электрического разъема, в основном используемый в профессиональном аудио-, видео- и сценическом осветительном оборудовании. Разъёмы XLR имеют цилиндрическую конструкцию, с тремя или семью контактами разъемов.
- Адаптер ArtNet-DMX – двунаправленный преобразователь Ethernet в DMX. Он обеспечивает двунаправленное преобразование с ArtNet на DMX-512.
- Вращающиеся головы – устройства, принцип действия которых основан на вращении прожектора, закрепленного на неподвижном основании, в горизонтальной и вертикальной плоскостях.
- Диммер – прибор для регулировки яркости света с фазоимпульсным управлением.
- Протокол DMX-512 – это протокол для управления сценическим освещением с различных пультов управления (консолей) через единый интерфейс, позволяющий объединять различные устройства управления с всевозможными осветительными приборами.
- Колорченджер – прибор для изменения цвета.
- Протокол ArtNet - протокол, основанный на протоколе UDP (User Datagram Protocol) и работающий поверх Ethernet. Он позволяет передавать информацию о цвете, интенсивности и других параметрах осветительных приборов, а также управлять ими из центрального управляющего устройства, такого как осветительная консоль или компьютер.
- Протокол TCP/IP– (Transmission Control Protocol/Internet Protocol) – это модель передачи цифровых данных. Протокол передачи TCP/IP описывает правила передачи данных, стандарты связи между компьютерами, а также содержит соглашения о маршрутизации и межсетевом взаимодействии. На его основе работает ArtNet.
- Светодиодный PAR-прожектор – прибор, который используется для образования рассеянного света и создания фоновой засветки.
- Свитчер – многоканальный выключатель с управлением по протоколу DMX-512.
- Сетевой коммутатор (от англ. switch — «переключатель») — устройство, предназначенное для соединения нескольких узлов компьютерной сети в пределах одного или нескольких сегментов сети.
- Узел (node) – устройство, поддерживающее максимум 1024 каналов DMX (2 Universe) на одном ip-адресе.

Power over Ethernet (PoE) – это технология, которая позволяет передавать электрическое питание через стандартные кабели Ethernet (например, Cat5e или Cat6), одновременно обеспечивая передачу данных. Это особенно полезно для устройств, таких как IP-камеры видеонаблюдения, точки доступа Wi-Fi, VoIP-телефоны и другие сетевые устройства, которым требуется питание, но прокладка отдельного силового кабеля может быть сложной или дорогостоящей задачей.

### Основные аспекты технологии PoE:

1. Стандарт IEEE 802.3af/at/bt: Технология PoE стандартизирована организацией IEEE (Institute of Electrical and Electronics Engineers). В настоящее время существует несколько стандартов PoE:
   - IEEE 802.3af: Первый стандарт PoE, выпущенный в 2003 году. Он обеспечивает до 15,4 Вт мощности на одно устройство.
   - IEEE 802.3at (PoE+): Обновленный стандарт, который был принят в 2009 году. Он увеличивает мощность до 30 Вт на порт.
   - IEEE 802.3bt (4PPoE): Самый новый стандарт, принятый в 2018 году. Он предлагает еще больше мощности – до 60 Вт или даже 100 Вт на порт при использовании всех четырех пар проводов в кабеле.
2. Принцип работы: PoE работает следующим образом: коммутатор или инжектор питания (PSE – Power Sourcing Equipment) подает напряжение постоянного тока через две пары проводников Ethernet-кабеля к питаемому устройству (PD – Powered Device). PD затем преобразует это напряжение в нужное ему значение.
3. Классификация PoE: В зависимости от стандарта и типа оборудования, PoE делится на классы мощности:
   - Класс 0: до 12,95 Вт (стандарт 802.3af)
   - Класс 1: до 3,84 Вт
   - Класс 2: до 6,49 Вт
   - Класс 3: до 12,95 Вт
   - Класс 4: до 25,50 Вт (стандарт 802.3at)
   - Класс 5: до 40 Вт (стандарт 802.3bt)
   - Класс 6: до 51 Вт (стандарт 802.3bt)
   - Класс 7: до 62 Вт (стандарт 802.3bt)
   - Класс 8: до 71,3 Вт (стандарт 802.3bt)
4. Преимущества использования PoE:
   - Упрощение установки и обслуживания сетевых устройств.
   - Экономия на прокладке силовых кабелей.
   - Возможность удаленного управления питанием устройств (например, перезагрузка камер видеонаблюдения).
   - Повышенная гибкость размещения устройств.